// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Depth
#pragma kernel DrawDepth
#pragma kernel Smooth
#pragma kernel ComputeNormals
#pragma kernel TSDFUpdate
#pragma kernel RenderTSDF

struct TSDF
{
    float tsdfValue;
    float weight;
};

Texture2D<float4> pixelBuffer;
RWTexture2D<float4> outputBuffer;
StructuredBuffer<uint> depthBuffer;
RWStructuredBuffer<uint> leftDepthBuffer;
RWStructuredBuffer<uint> smoothDepthBuffer;
RWStructuredBuffer<float3> normalBuffer;
RWStructuredBuffer<float3> vertexBuffer;
RWStructuredBuffer<TSDF> TSDFBuffer;
RWStructuredBuffer<float3> normalMapBuffer;
RWStructuredBuffer<float3> vertexMapBuffer;

uint imageWidth;
uint imageHeight;
float leftEyeTranslationDistance;

float spatialWeight;
float rangeWeight;
uint neighborSize;
float4x4 cameraMatrix;
float4x4 invCameraMatrix;
float truncationDist;
int voxelSize;
float roomSize;
float cameraScale;
float4x4 colorIntrinsicMatrix;
float4x4 invColorIntrinsicMatrix;
int rayTraceSteps;

float getDepth(int2 pos)
{
    int depth = depthBuffer[(pos.y * imageWidth + pos.x) / 2];
    int upperHalf = depth >> 16;
    int lowerHalf = depth & (0xFFFF);
    
    if ((pos.x & 1) == 0)
    {
        depth = lowerHalf;
    }
    else
    {
        depth = upperHalf;
    }
    //depth /= roomSize * 1000.0f / voxelSize / 2.0f;
    return depth;
}

[numthreads(8, 8, 1)]
void Depth(uint3 id : SV_DispatchThreadID)
{
    float depth = getDepth(id.xy);
    if (depth != 0)
    {
        float newPos = id.x - leftEyeTranslationDistance * imageWidth / depth;
        uint roundedNewPos = round(newPos);
        if (roundedNewPos >= 0 && roundedNewPos < imageWidth)
        {
            InterlockedMin(leftDepthBuffer[id.y * imageWidth + roundedNewPos], depth);
        }
    }
}

[numthreads(8, 8, 1)]
void DrawDepth(uint3 id : SV_DispatchThreadID)
{
    float depth = getDepth(id.xy);
    if (depth != 0)
    {
        float newPos = id.x - leftEyeTranslationDistance * imageWidth / depth;
        uint roundedNewPos = round(newPos);
        if (roundedNewPos >= 0 && roundedNewPos < imageWidth && leftDepthBuffer[id.y * imageWidth + roundedNewPos] == depth)
        {
            outputBuffer[int2(roundedNewPos, imageHeight - id.y - 1)] = pixelBuffer[int2(id.x, imageHeight - id.y - 1)];
        }
    }
    
    else
    {
        outputBuffer[int2(id.x, imageHeight - id.y - 1)] = pixelBuffer[int2(id.x, imageHeight - id.y - 1)];
    }
    
}

float bilateralFilterWeight(int2 origPos, int2 newPos)
{
    return exp(-((origPos.x - newPos.x) * (origPos.x - newPos.x) + (origPos.y - newPos.y) * (origPos.y - newPos.y)) * 1 / (spatialWeight * spatialWeight)) *
           exp(-((getDepth(origPos) - getDepth(newPos)) * (getDepth(origPos) - getDepth(newPos))) * 1 / (rangeWeight * rangeWeight));
}

[numthreads(8, 8, 1)]
void Smooth(int3 id : SV_DispatchThreadID)
{
    float normFactor = 0;
    float totWeight = 0;
    for (int a = 0; a < 2 * neighborSize; a++)
    {
        for (int b = 0; b < 2 * neighborSize; b++)
        {
            float currentWeight = bilateralFilterWeight(id.xy, int2(id.x + b - neighborSize, id.y + a - neighborSize));
            normFactor += currentWeight;
            totWeight += currentWeight * getDepth(int2(id.x + b - neighborSize, id.y + a - neighborSize));
        }
    }
    smoothDepthBuffer[id.y * imageWidth + id.x] = (int) ((float) totWeight / normFactor);
    vertexBuffer[id.y * imageWidth + id.x] = (int) ((float) totWeight / normFactor) * mul(invColorIntrinsicMatrix, float4(id.xy, 1, 1)).xyz / (roomSize * 1000.0f / voxelSize / 2.0f);
}

[numthreads(8, 8, 1)]
void ComputeNormals(int3 id : SV_DispatchThreadID)
{
    float3 normVector = cross(vertexBuffer[id.y * imageWidth + id.x + 1] - vertexBuffer[id.y * imageWidth + id.x],
                              vertexBuffer[(id.y + 1) * imageWidth + id.x] - vertexBuffer[id.y * imageWidth + id.x]);
    normalBuffer[id.y * imageWidth + id.x] = normalize(normVector);
}

[numthreads(8, 8, 8)]
void TSDFUpdate(int3 id : SV_DispatchThreadID)
{
    float3 globalPos = float3(id.x, id.y, id.z);
    float3 newPos = mul(colorIntrinsicMatrix, mul(invCameraMatrix, float4(globalPos, 1))).xyz;
    if (newPos.z > 0)
    {
        int2 projPoint = int2(round(newPos.x / newPos.z), round(newPos.y / newPos.z));
        if (projPoint.x >= 0 && projPoint.x < imageWidth && projPoint.y >= 0 && projPoint.y < imageHeight)
        {
            float depth = getDepth(projPoint);
            if (depth > 0)
            {
                float sdf = depth - newPos.z * roomSize * 1000.0f / voxelSize;
                //float sdf = depth - newPos.z;
                if (sdf >= -truncationDist)
                {
                    int pos = id.z * voxelSize * voxelSize + id.y * voxelSize + id.x;
                    TSDFBuffer[pos].tsdfValue = (TSDFBuffer[pos].tsdfValue * TSDFBuffer[pos].weight + min(1, sdf / truncationDist)) / (TSDFBuffer[pos].weight + 1);
                    TSDFBuffer[pos].weight++;

                }
            }
        }
    }
}

float getTSDFValue(int3 pos)
{
    return TSDFBuffer[pos.z * voxelSize * voxelSize + pos.y * voxelSize + pos.x].tsdfValue;
}

float trilinearInterpolate(float3 pos)
{
    int lowX = (int) pos.x;
    int lowY = (int) pos.y;
    int lowZ = (int) pos.z;
    int highX = (int) pos.x + 1;
    int highY = (int) pos.y + 1;
    int highZ = (int) pos.z + 1;
    return (pos.x - lowX) * (pos.y - lowY) * (pos.z - lowZ) * getTSDFValue(int3(highX, highY, highZ)) +
            (pos.x - lowX) * (pos.y - lowY) * (highZ - pos.z) * getTSDFValue(int3(highX, highY, lowZ)) +
            (pos.x - lowX) * (highY - pos.y) * (pos.z - lowZ) * getTSDFValue(int3(highX, lowY, highZ)) +
            (pos.x - lowX) * (highY - pos.y) * (highZ - pos.z) * getTSDFValue(int3(highX, lowY, lowZ)) +
            (highX - pos.x) * (pos.y - lowY) * (pos.z - lowZ) * getTSDFValue(int3(lowX, highY, highZ)) +
            (highX - pos.x) * (pos.y - lowY) * (highZ - pos.z) * getTSDFValue(int3(lowX, highY, lowZ)) +
            (highX - pos.x) * (highY - pos.y) * (pos.z - lowZ) * getTSDFValue(int3(lowX, lowY, highZ)) +
            (highX - pos.x) * (highY - pos.y) * (highZ - pos.z) * getTSDFValue(int3(lowX, lowY, lowZ));
}

[numthreads(8, 8, 1)]
void RenderTSDF(int3 id : SV_DispatchThreadID)
{
    float3 worldPos = mul(cameraMatrix, mul(invColorIntrinsicMatrix, float4(id.xy, 1, 1)));
    float3 worldDir = mul(cameraMatrix, mul(invColorIntrinsicMatrix, float4(id.xy, 1, 0)));
    worldDir = normalize(worldDir);
    float step = .01;
    float time = .01;
    float prevTSDF = 2;
    float prevTime = 0;
    worldPos += step * worldDir;
    for (int i = 0; i < rayTraceSteps; i++)
    {
        if (worldPos.x < 0 || worldPos.x >= voxelSize || worldPos.y < 0 || worldPos.y >= voxelSize || worldPos.z < 0 || worldPos.z >= voxelSize)
        {
            break;
        }
        float interpolatedTSDF = trilinearInterpolate(worldPos);
        if (interpolatedTSDF < 0)
        {
            float3 approxNorm = float3((trilinearInterpolate(float3(worldPos.x + 1e-4f, worldPos.yz)) - trilinearInterpolate(float3(worldPos.x - 1e-4f, worldPos.yz))) / 2e-4f,
                                       (trilinearInterpolate(float3(worldPos.x, worldPos.y + 1e-4f, worldPos.z)) - trilinearInterpolate(float3(worldPos.x, worldPos.y - 1e-4f, worldPos.z))) / 2e-4f,
                                       (trilinearInterpolate(float3(worldPos.xy, worldPos.z + 1e-4f)) - trilinearInterpolate(float3(worldPos.xy, worldPos.z - 1e-4f))) / 2e-4f);
            approxNorm = -normalize(approxNorm);
            float preciseTime = time - (step * prevTSDF) / (interpolatedTSDF - prevTSDF);
            float3 approxPos = worldPos + preciseTime * worldDir;
            //outputBuffer[int2(id.x, imageHeight - id.y - 1)] = float4(approxNorm, 1);
            //float intensity = dot(abs(approxNorm), worldDir);
            //intensity = clamp(intensity, 0, 1);
            //outputBuffer[int2(id.x, imageHeight - id.y - 1)] = float4(intensity, intensity, intensity, 1);
            normalMapBuffer[id.y * imageWidth + id.x] = approxNorm;
            vertexMapBuffer[id.y * imageWidth + id.x] = approxPos;
            //outputBuffer[int2(id.x, imageHeight - id.y - 1)] = float4(1 - i / (float) rayTraceSteps, 1 - i / (float) rayTraceSteps, 1 - i / (float) rayTraceSteps, 1);
            return;
        }
        step = max(.01, interpolatedTSDF * .9f);
        worldPos += worldDir * step;
        prevTime = time;
        prevTSDF = interpolatedTSDF;
        time += step;
    }
    
    //outputBuffer[int2(id.x, imageHeight - id.y - 1)] = float4(0, 0, 0, 1);
}