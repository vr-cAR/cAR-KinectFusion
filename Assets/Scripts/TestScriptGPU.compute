// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Depth
#pragma kernel DrawDepth
#pragma kernel FormatDepthBuffer
#pragma kernel Smooth
#pragma kernel ComputeNormals
#pragma kernel TSDFUpdate
#pragma kernel RenderTSDF
#pragma kernel ICP
#pragma kernel ICPOne
#pragma kernel ICPTwo
#pragma kernel ICPReduction
#pragma kernel DownsampleDepthOne
#pragma kernel DownsampleDepthTwo
#pragma kernel ComputeNormalsOne
#pragma kernel ComputeNormalsTwo
#pragma kernel ResizePointNormalsOne
#pragma kernel ResizePointNormalsTwo

struct TSDF
{
    float tsdfValue;
    float weight;
};

Texture2D<float4> pixelBuffer;
RWTexture2D<float4> outputBuffer;
RWStructuredBuffer<uint> depthBuffer;
RWStructuredBuffer<uint> leftDepthBuffer;
RWStructuredBuffer<float> smoothDepthBuffer;
RWStructuredBuffer<float> smoothDepthBufferOne;
RWStructuredBuffer<float> smoothDepthBufferTwo;
RWStructuredBuffer<float3> normalBuffer;
RWStructuredBuffer<float3> vertexBuffer;
RWStructuredBuffer<float3> normalBufferOne;
RWStructuredBuffer<float3> vertexBufferOne;
RWStructuredBuffer<float3> normalBufferTwo;
RWStructuredBuffer<float3> vertexBufferTwo;
RWStructuredBuffer<TSDF> TSDFBuffer;
RWStructuredBuffer<float3> normalMapBuffer;
RWStructuredBuffer<float3> vertexMapBuffer;
RWStructuredBuffer<float3> normalMapBufferOne;
RWStructuredBuffer<float3> vertexMapBufferOne;
RWStructuredBuffer<float3> normalMapBufferTwo;
RWStructuredBuffer<float3> vertexMapBufferTwo;
RWStructuredBuffer<float> ICPBuffer;
RWStructuredBuffer<float> ICPReductionBuffer;
RWStructuredBuffer<int> pointCloudBuffer;

uint imageWidth;
uint imageHeight;
float leftEyeTranslationDistance;

float spatialWeight;
float rangeWeight;
uint neighborSize;
float4x4 cameraMatrix;
float4x4 invCameraMatrix;
float truncationDist;
int voxelSize;
float roomSize;
float cameraScale;
float4x4 colorIntrinsicMatrix;
float4x4 colorIntrinsicMatrixOne;
float4x4 colorIntrinsicMatrixTwo;
float4x4 invColorIntrinsicMatrix;
float4x4 invColorIntrinsicMatrixOne;
float4x4 invColorIntrinsicMatrixTwo;
int rayTraceSteps;
float4x4 currentICPCameraMatrix;
float4x4 currentICPCameraMatrixInv;
float ICPThresholdDistance;
float ICPThresholdRotation;
int maxTSDFWeight;

groupshared float ICPSharedData[256][27];

[numthreads(64, 1, 1)]
void FormatDepthBuffer(int3 id : SV_DispatchThreadID)
{
    
    
    int pos = id.x * 3 + 2;
    int depth;  
    if ((pos & 1) != 0)
    {
        depth = pointCloudBuffer[pos / 2] >> 16;
    }
    else
    {
        depth = pointCloudBuffer[pos / 2] & (0xFFFF);
    }
    
    /*
    float posX = id.x / 512 - 256;
    float posY = (id.x & 511) - 256;
    if (posX * posX + posY * posY < 40000)
    {
        depthBuffer[id.x] = 500;
    }
    */
    depthBuffer[id.x] = depth;
}

float getDepth(int2 pos)
{
    /*
    int depth = depthBuffer[(pos.y * imageWidth + pos.x) / 2];
    int upperHalf = depth >> 16;
    int lowerHalf = depth & (0xFFFF);
    
    if ((pos.x & 1) == 0)
    {
        depth = lowerHalf;
    }
    else
    {
        depth = upperHalf;
    }
*/
    //depth /= roomSize * 1000.0f / voxelSize / 2.0f;
    return depthBuffer[pos.y * imageWidth + pos.x];
}

[numthreads(8, 8, 1)]
void Depth(uint3 id : SV_DispatchThreadID)
{
    float depth = getDepth(id.xy);
    if (depth != 0)
    {
        float newPos = id.x - leftEyeTranslationDistance * imageWidth / depth;
        uint roundedNewPos = round(newPos);
        if (roundedNewPos >= 0 && roundedNewPos < imageWidth)
        {
            InterlockedMin(leftDepthBuffer[id.y * imageWidth + roundedNewPos], depth);
        }
    }
}

[numthreads(8, 8, 1)]
void DrawDepth(uint3 id : SV_DispatchThreadID)
{
    float depth = getDepth(id.xy);
    if (depth != 0)
    {
        float newPos = id.x - leftEyeTranslationDistance * imageWidth / depth;
        uint roundedNewPos = round(newPos);
        if (roundedNewPos >= 0 && roundedNewPos < imageWidth && leftDepthBuffer[id.y * imageWidth + roundedNewPos] == depth)
        {
            outputBuffer[int2(roundedNewPos, imageHeight - id.y - 1)] = pixelBuffer[int2(id.x, imageHeight - id.y - 1)];
        }
    }
    
    else
    {
        outputBuffer[int2(id.x, imageHeight - id.y - 1)] = pixelBuffer[int2(id.x, imageHeight - id.y - 1)];
    }
    
}

float bilateralFilterWeight(int2 origPos, int2 newPos)
{
    float depthDiff = getDepth(origPos) - getDepth(newPos);
    return exp(-(dot(origPos - newPos, origPos - newPos)) * 1 / (spatialWeight * spatialWeight)) *
           exp(-(depthDiff * depthDiff) * 1 / (rangeWeight * rangeWeight));
}

[numthreads(8, 8, 1)]
void Smooth(int3 id : SV_DispatchThreadID)
{
    if (getDepth(id.xy) == 0)
    {
        smoothDepthBuffer[id.y * imageWidth + id.x] = 0;
        vertexBuffer[id.y * imageWidth + id.x] = float3(0, 0, 0);
        return;
    }
    float normFactor = 0;
    float totWeight = 0;
    int minY = max(0, id.y - (int) neighborSize);
    int minX = max(0, id.x - (int) neighborSize);
    int maxY = min(imageHeight - 1, id.y + (int) neighborSize);
    int maxX = min(imageWidth - 1, id.x + (int) neighborSize);
    for (int a = minY; a <= maxY; a++)
    {
        for (int b = minX; b <= maxX; b++)
        {
            float depth = getDepth(int2(b, a));
            if (depth == 0)
                continue;
            float currentWeight = bilateralFilterWeight(id.xy, int2(b, a));
            normFactor += currentWeight;
            totWeight += currentWeight * depth;
        }
    }
    smoothDepthBuffer[id.y * imageWidth + id.x] = ((float) totWeight / normFactor);
    vertexBuffer[id.y * imageWidth + id.x] = ((float) totWeight / normFactor) * mul(invColorIntrinsicMatrix, float4(id.xy, 1, 1)).xyz;
}

[numthreads(8, 8, 1)]
void DownsampleDepthOne(int3 id : SV_DispatchThreadID)
{
    int centerX = id.x * 2;
    int centerY = id.y * 2;
    int minX = max(0, centerX - 2);
    int minY = max(0, centerY - 2);
    int maxX = min(imageWidth - 1, centerX + 2);
    int maxY = min(imageHeight - 1, centerY + 2);
    float depth = smoothDepthBuffer[centerY * imageWidth + centerX];
    if (depth == 0)
    {
        smoothDepthBufferOne[id.y * imageWidth / 2 + id.x] = 0;
        vertexBufferOne[id.y * imageWidth / 2 + id.x] = float3(0, 0, 0);
        return;
    }
    float totWeight = 0;
    int count = 0;
    for (int a = minY; a <= maxY; a++)
    {
        for (int b = minX; b <= maxX; b++)
        {
            float curDepth = smoothDepthBuffer[a * imageWidth + b];
            if (abs(depth - curDepth) < 3 * rangeWeight)
            {
                totWeight += curDepth;
                count++;
            }
        }
    }
    smoothDepthBufferOne[id.y * imageWidth / 2 + id.x] = totWeight / count;
    vertexBufferOne[id.y * imageWidth / 2 + id.x] = (totWeight / count) * mul(invColorIntrinsicMatrixOne, float4(id.xy, 1, 1)).xyz;
}

[numthreads(8, 8, 1)]
void ComputeNormalsOne(int3 id : SV_DispatchThreadID)
{
    float3 normVector = cross(vertexBufferOne[id.y * imageWidth + id.x + 1] - vertexBufferOne[id.y * imageWidth + id.x],
                              vertexBufferOne[(id.y + 1) * imageWidth + id.x] - vertexBufferOne[id.y * imageWidth + id.x]);
    normalBufferOne[id.y * imageWidth + id.x] = normalize(normVector);
}

[numthreads(8, 8, 1)]
void DownsampleDepthTwo(int3 id : SV_DispatchThreadID)
{
    int centerX = id.x * 2;
    int centerY = id.y * 2;
    int minX = max(0, centerX - 2);
    int minY = max(0, centerY - 2);
    int maxX = min(imageWidth - 1, centerX + 2);
    int maxY = min(imageHeight - 1, centerY + 2);
    float depth = smoothDepthBufferOne[centerY * imageWidth / 2 + centerX];
    if (depth == 0)
    {
        smoothDepthBufferTwo[id.y * imageWidth / 4 + id.x] = 0;
        vertexBufferTwo[id.y * imageWidth / 4 + id.x] = float3(0, 0, 0);
        return;
    }
    float totWeight = 0;
    int count = 0;
    for (int a = minY; a <= maxY; a++)
    {
        for (int b = minX; b <= maxX; b++)
        {
            float curDepth = smoothDepthBufferOne[a * imageWidth / 2 + b];
            if (abs(depth - curDepth) < 3 * rangeWeight)
            {
                totWeight += curDepth;
                count++;
            }
        }
    }
    smoothDepthBufferTwo[id.y * imageWidth / 4 + id.x] = totWeight / count;
    vertexBufferTwo[id.y * imageWidth / 4 + id.x] = (totWeight / count) * mul(invColorIntrinsicMatrixTwo, float4(id.xy, 1, 1)).xyz;
}

[numthreads(8, 8, 1)]
void ComputeNormalsTwo(int3 id : SV_DispatchThreadID)
{
    float3 normVector = cross(vertexBufferTwo[id.y * imageWidth + id.x + 1] - vertexBufferTwo[id.y * imageWidth + id.x],
                              vertexBufferTwo[(id.y + 1) * imageWidth + id.x] - vertexBufferTwo[id.y * imageWidth + id.x]);
    normalBufferTwo[id.y * imageWidth + id.x] = normalize(normVector);
}

[numthreads(8, 8, 1)]
void ComputeNormals(int3 id : SV_DispatchThreadID)
{
    float3 normVector = cross(vertexBuffer[id.y * imageWidth + id.x + 1] - vertexBuffer[id.y * imageWidth + id.x],
                              vertexBuffer[(id.y + 1) * imageWidth + id.x] - vertexBuffer[id.y * imageWidth + id.x]);
    normalBuffer[id.y * imageWidth + id.x] = normalize(normVector);
}

[numthreads(8, 8, 8)]
void TSDFUpdate(int3 id : SV_DispatchThreadID)
{
    float3 globalPos = float3(id.x, id.y, id.z) * roomSize * 1000.0f / voxelSize;
    float3 newPos = mul(colorIntrinsicMatrix, mul(invCameraMatrix, float4(globalPos, 1))).xyz;
    if (newPos.z > 0)
    {
        int2 projPoint = int2(round(newPos.x / newPos.z), round(newPos.y / newPos.z));
        if (projPoint.x >= 0 && projPoint.x < imageWidth && projPoint.y >= 0 && projPoint.y < imageHeight)
        {
            float depth = getDepth(projPoint);
            if (depth > 0)
            {
                float sdf = depth - newPos.z;
                if (sdf >= -truncationDist)
                {
                    int pos = id.z * voxelSize * voxelSize + id.y * voxelSize + id.x;
                    TSDFBuffer[pos].tsdfValue = (TSDFBuffer[pos].tsdfValue * TSDFBuffer[pos].weight + min(1, sdf / truncationDist)) / (TSDFBuffer[pos].weight + 1);
                    TSDFBuffer[pos].weight = min(maxTSDFWeight, TSDFBuffer[pos].weight + 1);
                    //TSDFBuffer[pos].weight++;
                    //TSDFBuffer[pos].tsdfValue = min(1, sdf / truncationDist);

                }
            }
        }
    }
}

float getTSDFValue(int3 pos)
{
    return TSDFBuffer[pos.z * voxelSize * voxelSize + pos.y * voxelSize + pos.x].tsdfValue;
}

float trilinearInterpolate(float3 pos)
{
    int lowX = (int) pos.x;
    int lowY = (int) pos.y;
    int lowZ = (int) pos.z;
    int highX = (int) pos.x + 1;
    int highY = (int) pos.y + 1;
    int highZ = (int) pos.z + 1;
    return lerp(
                lerp(
                    lerp(getTSDFValue(int3(highX, highY, highZ)), getTSDFValue(int3(highX, highY, lowZ)), highZ - pos.z),
                    lerp(getTSDFValue(int3(highX, lowY, highZ)), getTSDFValue(int3(highX, lowY, lowZ)), highZ - pos.z),
                    highY - pos.y),
                lerp(
                    lerp(getTSDFValue(int3(lowX, highY, highZ)), getTSDFValue(int3(lowX, highY, lowZ)), highZ - pos.z),
                    lerp(getTSDFValue(int3(lowX, lowY, highZ)), getTSDFValue(int3(lowX, lowY, lowZ)), highZ - pos.z),
                    highY - pos.y),
                highX - pos.x);
    /*
    return (pos.x - lowX) * (pos.y - lowY) * (pos.z - lowZ) * getTSDFValue(int3(highX, highY, highZ)) +
            (pos.x - lowX) * (pos.y - lowY) * (highZ - pos.z) * getTSDFValue(int3(highX, highY, lowZ)) +
            (pos.x - lowX) * (highY - pos.y) * (pos.z - lowZ) * getTSDFValue(int3(highX, lowY, highZ)) +
            (pos.x - lowX) * (highY - pos.y) * (highZ - pos.z) * getTSDFValue(int3(highX, lowY, lowZ)) +
            (highX - pos.x) * (pos.y - lowY) * (pos.z - lowZ) * getTSDFValue(int3(lowX, highY, highZ)) +
            (highX - pos.x) * (pos.y - lowY) * (highZ - pos.z) * getTSDFValue(int3(lowX, highY, lowZ)) +
            (highX - pos.x) * (highY - pos.y) * (pos.z - lowZ) * getTSDFValue(int3(lowX, lowY, highZ)) +
            (highX - pos.x) * (highY - pos.y) * (highZ - pos.z) * getTSDFValue(int3(lowX, lowY, lowZ));
    */
}

[numthreads(8, 8, 1)]
void RenderTSDF(int3 id : SV_DispatchThreadID)
{
    normalMapBuffer[id.y * imageWidth + id.x] = float3(0, 0, 0);
    vertexMapBuffer[id.y * imageWidth + id.x] = float3(0, 0, 0);
    float3 worldPos = float3(cameraMatrix[0][3], cameraMatrix[1][3], cameraMatrix[2][3]) / (roomSize * 1000.0f / voxelSize);
    float3 worldDir = mul(cameraMatrix, mul(invColorIntrinsicMatrix, float4(id.xy, 1, 0))).xyz;
    worldDir = normalize(worldDir);
    float step = .1;
    float time = .1;
    float prevTSDF = trilinearInterpolate(worldPos);
    float prevTime = 0;
    worldPos += step * worldDir;
    for (int i = 0; i < rayTraceSteps; i++)
    {
        if (worldPos.x < 0 || worldPos.x >= voxelSize || worldPos.y < 0 || worldPos.y >= voxelSize || worldPos.z < 0 || worldPos.z >= voxelSize)
        {
            break;
        }
        float interpolatedTSDF = trilinearInterpolate(worldPos);
        if (prevTSDF < 0 && interpolatedTSDF > 0)
            break;
        if (prevTSDF > 0 && interpolatedTSDF < 0)
        {
            float3 approxNorm = float3((trilinearInterpolate(float3(worldPos.x + .5, worldPos.yz)) - trilinearInterpolate(float3(worldPos.x - .5, worldPos.yz))) / .5,
                                       (trilinearInterpolate(float3(worldPos.x, worldPos.y + .5, worldPos.z)) - trilinearInterpolate(float3(worldPos.x, worldPos.y - .5, worldPos.z))) / .5,
                                       (trilinearInterpolate(float3(worldPos.xy, worldPos.z + .5)) - trilinearInterpolate(float3(worldPos.xy, worldPos.z - .5))) / .5);
            approxNorm = -normalize(approxNorm);
            float preciseTime = prevTime - (step * prevTSDF) / (interpolatedTSDF - prevTSDF);
            float3 approxPos = float3(cameraMatrix[0][3], cameraMatrix[1][3], cameraMatrix[2][3]) / (roomSize * 1000.0f / voxelSize) + preciseTime * worldDir;
            //outputBuffer[int2(id.x, imageHeight - id.y - 1)] = float4(approxNorm, 1);
            float intensity = dot(approxNorm, worldDir);
            intensity = clamp(intensity, 0, 1);
            outputBuffer[int2(id.x, imageHeight - id.y - 1)] = float4(intensity, intensity, intensity, 1);
            normalMapBuffer[id.y * imageWidth + id.x] = approxNorm;
            vertexMapBuffer[id.y * imageWidth + id.x] = approxPos * roomSize * 1000.0f / voxelSize;
            //outputBuffer[int2(id.x, imageHeight - id.y - 1)] = float4(1 - i / (float) rayTraceSteps, 1 - i / (float) rayTraceSteps, 1 - i / (float) rayTraceSteps, 1);
            return;
        }
        step = max(.1, interpolatedTSDF * .75f);
        worldPos += worldDir * step;
        prevTime = time;
        prevTSDF = interpolatedTSDF;
        time += step;
    }
    outputBuffer[int2(id.x, imageHeight - id.y - 1)] = float4(0, 0, 0, 1);
}

[numthreads(8, 8, 1)]
void ResizePointNormalsOne(int3 id : SV_DispatchThreadID)
{
    int curX = id.x * 2;
    int curY = id.y * 2;
    float3 pointOne = vertexMapBuffer[curY * imageWidth + curX];
    float3 pointTwo = vertexMapBuffer[curY * imageWidth + curX + 1];
    float3 pointThree = vertexMapBuffer[(curY + 1) * imageWidth + curX];
    float3 pointFour = vertexMapBuffer[(curY + 1) * imageWidth + curX + 1];
    if (pointOne.z * pointTwo.z * pointThree.z * pointFour.z == 0)
    {
        vertexMapBufferOne[id.y * imageWidth / 2 + id.x] = float3(0, 0, 0);
        normalMapBufferOne[id.y * imageWidth / 2 + id.x] = float3(0, 0, 0);
        return;
    }
    float3 normalOne = normalMapBuffer[curY * imageWidth + curX];
    float3 normalTwo = normalMapBuffer[curY * imageWidth + curX + 1];
    float3 normalThree = normalMapBuffer[(curY + 1) * imageWidth + curX];
    float3 normalFour = normalMapBuffer[(curY + 1) * imageWidth + curX + 1];
    vertexMapBufferOne[id.y * imageWidth / 2 + id.x] = (pointOne + pointTwo + pointThree + pointFour) * .25f;
    normalMapBufferOne[id.y * imageWidth / 2 + id.x] = (normalOne + normalTwo + normalThree + normalFour) * .25f;
}

[numthreads(8, 8, 1)]
void ResizePointNormalsTwo(int3 id : SV_DispatchThreadID)
{
    int curX = id.x * 2;
    int curY = id.y * 2;
    float3 pointOne = vertexMapBufferOne[curY * imageWidth / 2 + curX];
    float3 pointTwo = vertexMapBufferOne[curY * imageWidth / 2 + curX + 1];
    float3 pointThree = vertexMapBufferOne[(curY + 1) * imageWidth / 2 + curX];
    float3 pointFour = vertexMapBufferOne[(curY + 1) * imageWidth / 2 + curX + 1];
    if (pointOne.z * pointTwo.z * pointThree.z * pointFour.z == 0)
    {
        vertexMapBufferTwo[id.y * imageWidth / 4 + id.x] = float3(0, 0, 0);
        normalMapBufferTwo[id.y * imageWidth / 4 + id.x] = float3(0, 0, 0);
        return;
    }
    float3 normalOne = normalMapBufferOne[curY * imageWidth / 2 + curX];
    float3 normalTwo = normalMapBufferOne[curY * imageWidth / 2 + curX + 1];
    float3 normalThree = normalMapBufferOne[(curY + 1) * imageWidth / 2 + curX];
    float3 normalFour = normalMapBufferOne[(curY + 1) * imageWidth / 2 + curX + 1];
    vertexMapBufferTwo[id.y * imageWidth / 4 + id.x] = (pointOne + pointTwo + pointThree + pointFour) * .25f;
    normalMapBufferTwo[id.y * imageWidth / 4 + id.x] = (normalOne + normalTwo + normalThree + normalFour) * .25f;
}

[numthreads(8, 8, 1)]
void ICP(int3 id : SV_DispatchThreadID, int3 threadID : SV_GroupThreadID, int3 groupID : SV_GroupID)
{
    //int ICPStartIndex = (imageHeight - id.y - 1) * imageWidth + id.x;
    int ICPStartIndex = id.y * imageWidth + id.x;
    float4 currentVertex = float4(vertexBuffer[ICPStartIndex], 1);
    bool isValid = true;
    [flatten]
    if (currentVertex.z == 0)
    {
        isValid = false;
    }
    float4x4 FrameToFrameTransform = mul(invCameraMatrix, currentICPCameraMatrix);
    float4 projPoint = mul(colorIntrinsicMatrix, mul(FrameToFrameTransform, currentVertex));
    int2 newPoint = int2(round(projPoint.x / projPoint.z), round(projPoint.y / projPoint.z));
    [flatten]
    if (newPoint.x < 0 || newPoint.x >= imageWidth || newPoint.y < 0 || newPoint.y >= imageHeight)
    {
        isValid = false;
    }
    float4 prevVertex = float4(vertexMapBuffer[newPoint.y * imageWidth + newPoint.x], 1);
    [flatten]
    if (prevVertex.z == 0)
    {
        isValid = false;
    }
    float4 estimateVertex = mul(currentICPCameraMatrix, currentVertex);
    [flatten]
    if (distance(estimateVertex, prevVertex) > ICPThresholdDistance)
    {
        isValid = false;
    }
    float4 currentNormal = float4(normalBuffer[id.y * imageWidth + id.x], 0);
    float4 prevNormal = float4(normalMapBuffer[newPoint.y * imageWidth + newPoint.x], 0);
    [flatten]
    if (!isfinite(currentNormal.x) || length(currentNormal) < .1 || !isfinite(prevNormal.x) || length(prevNormal) < .1)
    {
        isValid = false;
    }
    currentNormal = mul(currentICPCameraMatrix, currentNormal);
    [flatten]
    if (abs(dot(currentNormal, prevNormal)) < ICPThresholdRotation)
    {
        isValid = false;
    }
    float3 crossProd = cross(estimateVertex.xyz, prevNormal.xyz);
    float ATransposeVector[6] =
    {
        crossProd.x,
        crossProd.y,
        crossProd.z,
        prevNormal.x,
        prevNormal.y,
        prevNormal.z
    };
    float bScalar = dot(prevNormal, estimateVertex - prevVertex);
    int groupIdx = threadID.y * 8 + threadID.x;
    if (isValid)
    {
        [unroll]
        for (int i = 0; i < 6; i++)
        {
            ICPSharedData[groupIdx][21 + i] = bScalar * ATransposeVector[i];
            [unroll]
            for (int j = i; j < 6; j++)
            {
                ICPSharedData[groupIdx][i * 6 - i * (i - 1) / 2 + j - i] = ATransposeVector[i] * ATransposeVector[j];
            }
        }
    }
    else
    {
        [unroll]
        for (int i = 0; i < 27; i++)
        {
            ICPSharedData[groupIdx][i] = 0;
        }
    }
    GroupMemoryBarrierWithGroupSync();
    [unroll]
    for (int step = 64 / 2; step > 1; step >>= 1)
    {
        if (groupIdx < step)
        {
            [unroll]
            for (int i = 0; i < 27; i++)
            {
                ICPSharedData[groupIdx][i] += ICPSharedData[groupIdx + step][i];
            }
        }
        GroupMemoryBarrierWithGroupSync();
    }
    
    if (groupIdx == 0)
    {
        [unroll]
        for (int i = 0; i < 27; i++)
        {
            ICPBuffer[(groupID.y * imageWidth / 8 + groupID.x) * 27 + i] = ICPSharedData[0][i] + ICPSharedData[1][i];
        }
    }

}

[numthreads(8, 8, 1)]
void ICPOne(int3 id : SV_DispatchThreadID, int3 threadID : SV_GroupThreadID, int3 groupID : SV_GroupID)
{
    int ICPStartIndex = id.y * imageWidth / 2 + id.x;
    float4 currentVertex = float4(vertexBufferOne[ICPStartIndex], 1);
    bool isValid = true;
    [flatten]
    if (currentVertex.z == 0)
    {
        isValid = false;
    }
    float4x4 FrameToFrameTransform = mul(invCameraMatrix, currentICPCameraMatrix);
    float4 projPoint = mul(colorIntrinsicMatrixOne, mul(FrameToFrameTransform, currentVertex));
    int2 newPoint = int2(round(projPoint.x / projPoint.z), round(projPoint.y / projPoint.z));
    [flatten]
    if (newPoint.x < 0 || newPoint.x >= imageWidth / 2 || newPoint.y < 0 || newPoint.y >= imageHeight / 2)
    {
        isValid = false;
    }
    float4 prevVertex = float4(vertexMapBufferOne[newPoint.y * imageWidth / 2 + newPoint.x], 1);
    [flatten]
    if (prevVertex.z == 0)
    {
        isValid = false;
    }
    float4 estimateVertex = mul(currentICPCameraMatrix, currentVertex);
    [flatten]
    if (distance(estimateVertex, prevVertex) > ICPThresholdDistance)
    {
        isValid = false;
    }
    float4 currentNormal = float4(normalBufferOne[id.y * imageWidth / 2 + id.x], 0);
    float4 prevNormal = float4(normalMapBufferOne[newPoint.y * imageWidth / 2 + newPoint.x], 0);
    [flatten]
    if (!isfinite(currentNormal.x) || length(currentNormal) < .1 || !isfinite(prevNormal.x) || length(prevNormal) < .1)
    {
        isValid = false;
    }
    currentNormal = mul(currentICPCameraMatrix, currentNormal);
    [flatten]
    if (abs(dot(currentNormal, prevNormal)) < ICPThresholdRotation)
    {
        isValid = false;
    }
    float3 crossProd = cross(estimateVertex.xyz, prevNormal.xyz);
    float ATransposeVector[6] =
    {
        crossProd.x,
        crossProd.y,
        crossProd.z,
        prevNormal.x,
        prevNormal.y,
        prevNormal.z
    };
    float bScalar = dot(prevNormal, estimateVertex - prevVertex);
    int groupIdx = threadID.y * 8 + threadID.x;
    if (isValid)
    {
        [unroll]
        for (int i = 0; i < 6; i++)
        {
            ICPSharedData[groupIdx][21 + i] = bScalar * ATransposeVector[i];
            [unroll]
            for (int j = i; j < 6; j++)
            {
                ICPSharedData[groupIdx][i * 6 - i * (i - 1) / 2 + j - i] = ATransposeVector[i] * ATransposeVector[j];
            }
        }
    }
    else
    {
        [unroll]
        for (int i = 0; i < 27; i++)
        {
            ICPSharedData[groupIdx][i] = 0;
        }
    }
    GroupMemoryBarrierWithGroupSync();
    [unroll]
    for (int step = 64 / 2; step > 1; step >>= 1)
    {
        if (groupIdx < step)
        {
            [unroll]
            for (int i = 0; i < 27; i++)
            {
                ICPSharedData[groupIdx][i] += ICPSharedData[groupIdx + step][i];
            }
        }
        GroupMemoryBarrierWithGroupSync();
    }
    
    if (groupIdx == 0)
    {
        [unroll]
        for (int i = 0; i < 27; i++)
        {
            ICPBuffer[(groupID.y * imageWidth / 2 / 8 + groupID.x) * 27 + i] = ICPSharedData[0][i] + ICPSharedData[1][i];
        }
    }
}

[numthreads(8, 8, 1)]
void ICPTwo(int3 id : SV_DispatchThreadID, int3 threadID : SV_GroupThreadID, int3 groupID : SV_GroupID)
{
    int ICPStartIndex = id.y * imageWidth / 4 + id.x;
    float4 currentVertex = float4(vertexBufferTwo[ICPStartIndex], 1);
    bool isValid = true;
    [flatten]
    if (currentVertex.z == 0)
    {
        isValid = false;
    }
    float4x4 FrameToFrameTransform = mul(invCameraMatrix, currentICPCameraMatrix);
    float4 projPoint = mul(colorIntrinsicMatrixTwo, mul(FrameToFrameTransform, currentVertex));
    int2 newPoint = int2(round(projPoint.x / projPoint.z), round(projPoint.y / projPoint.z));
    [flatten]
    if (newPoint.x < 0 || newPoint.x >= imageWidth / 4 || newPoint.y < 0 || newPoint.y >= imageHeight / 4)
    {
        isValid = false;
    }
    float4 prevVertex = float4(vertexMapBufferTwo[newPoint.y * imageWidth / 4 + newPoint.x], 1);
    [flatten]
    if (prevVertex.z == 0)
    {
        isValid = false;
    }
    float4 estimateVertex = mul(currentICPCameraMatrix, currentVertex);
    [flatten]
    if (distance(estimateVertex, prevVertex) > ICPThresholdDistance)
    {
        isValid = false;
    }
    float4 currentNormal = float4(normalBufferTwo[id.y * imageWidth / 4 + id.x], 0);
    float4 prevNormal = float4(normalMapBufferTwo[newPoint.y * imageWidth / 4 + newPoint.x], 0);
    [flatten]
    if (!isfinite(currentNormal.x) || length(currentNormal) < .1 || !isfinite(prevNormal.x) || length(prevNormal) < .1)
    {
        isValid = false;
    }
    currentNormal = mul(currentICPCameraMatrix, currentNormal);
    [flatten]
    if (abs(dot(currentNormal, prevNormal)) < ICPThresholdRotation)
    {
        isValid = false;
    }
    float3 crossProd = cross(estimateVertex.xyz, prevNormal.xyz);
    float ATransposeVector[6] =
    {
        crossProd.x,
        crossProd.y,
        crossProd.z,
        prevNormal.x,
        prevNormal.y,
        prevNormal.z
    };
    float bScalar = dot(prevNormal, estimateVertex - prevVertex);
    int groupIdx = threadID.y * 8 + threadID.x;
    if (isValid)
    {
        [unroll]
        for (int i = 0; i < 6; i++)
        {
            ICPSharedData[groupIdx][21 + i] = bScalar * ATransposeVector[i];
            [unroll]
            for (int j = i; j < 6; j++)
            {
                ICPSharedData[groupIdx][i * 6 - i * (i - 1) / 2 + j - i] = ATransposeVector[i] * ATransposeVector[j];
            }
        }
    }
    else
    {
        [unroll]
        for (int i = 0; i < 27; i++)
        {
            ICPSharedData[groupIdx][i] = 0;
        }
    }
    GroupMemoryBarrierWithGroupSync();
    [unroll]
    for (int step = 64 / 2; step > 1; step >>= 1)
    {
        if (groupIdx < step)
        {
            [unroll]
            for (int i = 0; i < 27; i++)
            {
                ICPSharedData[groupIdx][i] += ICPSharedData[groupIdx + step][i];
            }
        }
        GroupMemoryBarrierWithGroupSync();
    }
    
    if (groupIdx == 0)
    {
        [unroll]
        for (int i = 0; i < 27; i++)
        {
            ICPBuffer[(groupID.y * imageWidth / 4 / 8 + groupID.x) * 27 + i] = ICPSharedData[0][i] + ICPSharedData[1][i];
        }
    }
}

[numthreads(256, 1, 1)]
void ICPReduction(int3 id : SV_DispatchThreadID, int3 threadID : SV_GroupThreadID, int3 groupID : SV_GroupID)
{
    int pos = groupID.x * 256 * 2 + threadID.x;
    [unroll]
    for (int i = 0; i < 27; i++)
    {
        ICPSharedData[threadID.x][i] = ICPBuffer[pos * 27 + i] + ICPBuffer[(pos + 256) * 27 + i];
    }
    GroupMemoryBarrierWithGroupSync();
    for (int step = 256 / 2; step > 0; step >>= 1)
    {
        if (threadID.x < step)
        {
            [unroll]
            for (int i = 0; i < 27; i++)
            {
                ICPSharedData[threadID.x][i] += ICPSharedData[threadID.x + step][i];
            }
        }
        GroupMemoryBarrierWithGroupSync();
    }
    if (threadID.x == 0)
    {
        [unroll]
        for (int i = 0; i < 27; i++)
        {
            ICPReductionBuffer[groupID.x * 27 + i] = ICPSharedData[0][i];
        }
    }
}