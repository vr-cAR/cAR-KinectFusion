// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Depth
#pragma kernel DrawDepth
#pragma kernel FormatDepthBuffer
#pragma kernel Smooth
#pragma kernel ComputeNormals
#pragma kernel TSDFUpdate
#pragma kernel RenderTSDF
#pragma kernel ICP
#pragma kernel ICPReduction

struct TSDF
{
    float tsdfValue;
    float weight;
};

Texture2D<float4> pixelBuffer;
RWTexture2D<float4> outputBuffer;
RWStructuredBuffer<uint> depthBuffer;
RWStructuredBuffer<uint> leftDepthBuffer;
RWStructuredBuffer<float> smoothDepthBuffer;
RWStructuredBuffer<float3> normalBuffer;
RWStructuredBuffer<float3> vertexBuffer;
RWStructuredBuffer<TSDF> TSDFBuffer;
RWStructuredBuffer<float3> normalMapBuffer;
RWStructuredBuffer<float3> vertexMapBuffer;
RWStructuredBuffer<float> ICPBuffer;
RWStructuredBuffer<float> ICPReductionBuffer;
RWStructuredBuffer<int> pointCloudBuffer;

RWStructuredBuffer<float3> normalBufferPrevTest;
RWStructuredBuffer<float3> vertexBufferPrevTest;

uint imageWidth;
uint imageHeight;
float leftEyeTranslationDistance;

float spatialWeight;
float rangeWeight;
uint neighborSize;
float4x4 cameraMatrix;
float4x4 invCameraMatrix;
float truncationDist;
int voxelSize;
float roomSize;
float cameraScale;
float4x4 colorIntrinsicMatrix;
float4x4 invColorIntrinsicMatrix;
int rayTraceSteps;
float4x4 currentICPCameraMatrix;
float4x4 currentICPCameraMatrixInv;
float ICPThresholdDistance;
float ICPThresholdRotation;
int maxTSDFWeight;

groupshared float ICPSharedData[256][27];

[numthreads(64, 1, 1)]
void FormatDepthBuffer(int3 id : SV_DispatchThreadID)
{
    
    
    int pos = id.x * 3 + 2;
    int depth;  
    if ((pos & 1) != 0)
    {
        depth = pointCloudBuffer[pos / 2] >> 16;
    }
    else
    {
        depth = pointCloudBuffer[pos / 2] & (0xFFFF);
    }
    
    /*
    float posX = id.x / 512 - 256;
    float posY = (id.x & 511) - 256;
    if (posX * posX + posY * posY < 40000)
    {
        depthBuffer[id.x] = 500;
    }
    */
    depthBuffer[id.x] = depth;
}

float getDepth(int2 pos)
{
    /*
    int depth = depthBuffer[(pos.y * imageWidth + pos.x) / 2];
    int upperHalf = depth >> 16;
    int lowerHalf = depth & (0xFFFF);
    
    if ((pos.x & 1) == 0)
    {
        depth = lowerHalf;
    }
    else
    {
        depth = upperHalf;
    }
*/
    //depth /= roomSize * 1000.0f / voxelSize / 2.0f;
    return depthBuffer[pos.y * imageWidth + pos.x];
}

[numthreads(8, 8, 1)]
void Depth(uint3 id : SV_DispatchThreadID)
{
    float depth = getDepth(id.xy);
    if (depth != 0)
    {
        float newPos = id.x - leftEyeTranslationDistance * imageWidth / depth;
        uint roundedNewPos = round(newPos);
        if (roundedNewPos >= 0 && roundedNewPos < imageWidth)
        {
            InterlockedMin(leftDepthBuffer[id.y * imageWidth + roundedNewPos], depth);
        }
    }
}

[numthreads(8, 8, 1)]
void DrawDepth(uint3 id : SV_DispatchThreadID)
{
    float depth = getDepth(id.xy);
    if (depth != 0)
    {
        float newPos = id.x - leftEyeTranslationDistance * imageWidth / depth;
        uint roundedNewPos = round(newPos);
        if (roundedNewPos >= 0 && roundedNewPos < imageWidth && leftDepthBuffer[id.y * imageWidth + roundedNewPos] == depth)
        {
            outputBuffer[int2(roundedNewPos, imageHeight - id.y - 1)] = pixelBuffer[int2(id.x, imageHeight - id.y - 1)];
        }
    }
    
    else
    {
        outputBuffer[int2(id.x, imageHeight - id.y - 1)] = pixelBuffer[int2(id.x, imageHeight - id.y - 1)];
    }
    
}

float bilateralFilterWeight(int2 origPos, int2 newPos)
{
    float depthDiff = getDepth(origPos) - getDepth(newPos);
    return exp(-(dot(origPos - newPos, origPos - newPos)) * 1 / (spatialWeight * spatialWeight)) *
           exp(-(depthDiff * depthDiff) * 1 / (rangeWeight * rangeWeight));
}

[numthreads(8, 8, 1)]
void Smooth(int3 id : SV_DispatchThreadID)
{
    if (getDepth(id.xy) == 0)
    {
        smoothDepthBuffer[id.y * imageWidth + id.x] = 0;
        vertexBuffer[id.y * imageWidth + id.x] = float3(0, 0, 0);
        return;
    }
    float normFactor = 0;
    float totWeight = 0;
    for (int a = 0; a < 2 * neighborSize; a++)
    {
        for (int b = 0; b < 2 * neighborSize; b++)
        {
            float depth = getDepth(int2(id.x + b - neighborSize, id.y + a - neighborSize));
            if (depth == 0)
                continue;
            float currentWeight = bilateralFilterWeight(id.xy, int2(id.x + b - neighborSize, id.y + a - neighborSize));
            normFactor += currentWeight;
            totWeight += currentWeight * depth;
        }
    }
    //smoothDepthBuffer[id.y * imageWidth + id.x] = ((float) totWeight / normFactor);
    //smoothDepthBuffer[id.y * imageWidth + id.x] = ((float) totWeight / normFactor) / (roomSize * 1000.0f / voxelSize);
    smoothDepthBuffer[id.y * imageWidth + id.x] = ((float) totWeight / normFactor);
    vertexBufferPrevTest[id.y * imageWidth + id.x] = vertexBuffer[id.y * imageWidth + id.x];
    //vertexBuffer[id.y * imageWidth + id.x] = ((float) totWeight / normFactor) * mul(invColorIntrinsicMatrix, float4(id.xy, 1, 1)).xyz / (roomSize * 1000.0f / voxelSize);
    vertexBuffer[id.y * imageWidth + id.x] = ((float) totWeight / normFactor) * mul(invColorIntrinsicMatrix, float4(id.xy, 1, 1)).xyz;
}

[numthreads(8, 8, 1)]
void ComputeNormals(int3 id : SV_DispatchThreadID)
{
    float3 normVector = cross(vertexBuffer[id.y * imageWidth + id.x + 1] - vertexBuffer[id.y * imageWidth + id.x],
                              vertexBuffer[(id.y + 1) * imageWidth + id.x] - vertexBuffer[id.y * imageWidth + id.x]);
    normalBufferPrevTest[id.y * imageWidth + id.x] = normalBuffer[id.y * imageWidth + id.x];
    normalBuffer[id.y * imageWidth + id.x] = normalize(normVector);
}

[numthreads(8, 8, 8)]
void TSDFUpdate(int3 id : SV_DispatchThreadID)
{
    float3 globalPos = float3(id.x, id.y, id.z) * roomSize * 1000.0f / voxelSize;
    float3 newPos = mul(colorIntrinsicMatrix, mul(invCameraMatrix, float4(globalPos, 1))).xyz;
    if (newPos.z > 0)
    {
        int2 projPoint = int2(round(newPos.x / newPos.z), round(newPos.y / newPos.z));
        if (projPoint.x >= 0 && projPoint.x < imageWidth && projPoint.y >= 0 && projPoint.y < imageHeight)
        {
            float depth = getDepth(projPoint);
            if (depth > 0)
            {
                float sdf = depth - newPos.z;
                //float sdf = length(mul(invColorIntrinsicMatrix, float4(projPoint.xy, 1, 1)).xyz * depth) - length(mul(invCameraMatrix, float4(globalPos, 1)).xyz * roomSize * 1000.0f / voxelSize);
                //float sdf = depth - sqrt(dot(newPos, newPos)) * roomSize / voxelSize;
                if (sdf >= -truncationDist)
                {
                    int pos = id.z * voxelSize * voxelSize + id.y * voxelSize + id.x;
                    TSDFBuffer[pos].tsdfValue = (TSDFBuffer[pos].tsdfValue * TSDFBuffer[pos].weight + min(1, sdf / truncationDist)) / (TSDFBuffer[pos].weight + 1);
                    TSDFBuffer[pos].weight = min(maxTSDFWeight, TSDFBuffer[pos].weight + 1);
                    //TSDFBuffer[pos].weight++;
                    //TSDFBuffer[pos].tsdfValue = min(1, sdf / truncationDist);

                }
            }
        }
    }
}

float getTSDFValue(int3 pos)
{
    return TSDFBuffer[pos.z * voxelSize * voxelSize + pos.y * voxelSize + pos.x].tsdfValue;
}

float trilinearInterpolate(float3 pos)
{
    int lowX = (int) pos.x;
    int lowY = (int) pos.y;
    int lowZ = (int) pos.z;
    int highX = (int) pos.x + 1;
    int highY = (int) pos.y + 1;
    int highZ = (int) pos.z + 1;
    return lerp(
                lerp(
                    lerp(getTSDFValue(int3(highX, highY, highZ)), getTSDFValue(int3(highX, highY, lowZ)), highZ - pos.z),
                    lerp(getTSDFValue(int3(highX, lowY, highZ)), getTSDFValue(int3(highX, lowY, lowZ)), highZ - pos.z),
                    highY - pos.y),
                lerp(
                    lerp(getTSDFValue(int3(lowX, highY, highZ)), getTSDFValue(int3(lowX, highY, lowZ)), highZ - pos.z),
                    lerp(getTSDFValue(int3(lowX, lowY, highZ)), getTSDFValue(int3(lowX, lowY, lowZ)), highZ - pos.z),
                    highY - pos.y),
                highX - pos.x);
    /*
    return (pos.x - lowX) * (pos.y - lowY) * (pos.z - lowZ) * getTSDFValue(int3(highX, highY, highZ)) +
            (pos.x - lowX) * (pos.y - lowY) * (highZ - pos.z) * getTSDFValue(int3(highX, highY, lowZ)) +
            (pos.x - lowX) * (highY - pos.y) * (pos.z - lowZ) * getTSDFValue(int3(highX, lowY, highZ)) +
            (pos.x - lowX) * (highY - pos.y) * (highZ - pos.z) * getTSDFValue(int3(highX, lowY, lowZ)) +
            (highX - pos.x) * (pos.y - lowY) * (pos.z - lowZ) * getTSDFValue(int3(lowX, highY, highZ)) +
            (highX - pos.x) * (pos.y - lowY) * (highZ - pos.z) * getTSDFValue(int3(lowX, highY, lowZ)) +
            (highX - pos.x) * (highY - pos.y) * (pos.z - lowZ) * getTSDFValue(int3(lowX, lowY, highZ)) +
            (highX - pos.x) * (highY - pos.y) * (highZ - pos.z) * getTSDFValue(int3(lowX, lowY, lowZ));
    */
}

[numthreads(8, 8, 1)]
void RenderTSDF(int3 id : SV_DispatchThreadID)
{
    normalMapBuffer[id.y * imageWidth + id.x] = float3(0, 0, 0);
    vertexMapBuffer[id.y * imageWidth + id.x] = float3(0, 0, 0);
    //float3 worldPos = mul(cameraMatrix, mul(invColorIntrinsicMatrix, float4(id.xy, 1, 1))).xyz;
    float3 worldPos = float3(cameraMatrix[0][3], cameraMatrix[1][3], cameraMatrix[2][3]) / (roomSize * 1000.0f / voxelSize);
    float3 worldDir = mul(cameraMatrix, mul(invColorIntrinsicMatrix, float4(id.xy, 1, 0))).xyz;
    worldDir = normalize(worldDir);
    float step = .1;
    float time = .1;
    float prevTSDF = trilinearInterpolate(worldPos);
    float prevTime = 0;
    worldPos += step * worldDir;
    for (int i = 0; i < rayTraceSteps; i++)
    {
        if (worldPos.x < 0 || worldPos.x >= voxelSize || worldPos.y < 0 || worldPos.y >= voxelSize || worldPos.z < 0 || worldPos.z >= voxelSize)
        {
            break;
        }
        float interpolatedTSDF = trilinearInterpolate(worldPos);
        if (prevTSDF < 0 && interpolatedTSDF > 0)
            break;
        if (prevTSDF > 0 && interpolatedTSDF < 0)
        {
            float3 approxNorm = float3((trilinearInterpolate(float3(worldPos.x + .5, worldPos.yz)) - trilinearInterpolate(float3(worldPos.x - .5, worldPos.yz))) / .5,
                                       (trilinearInterpolate(float3(worldPos.x, worldPos.y + .5, worldPos.z)) - trilinearInterpolate(float3(worldPos.x, worldPos.y - .5, worldPos.z))) / .5,
                                       (trilinearInterpolate(float3(worldPos.xy, worldPos.z + .5)) - trilinearInterpolate(float3(worldPos.xy, worldPos.z - .5))) / .5);
            approxNorm = -normalize(approxNorm);
            float preciseTime = prevTime - (step * prevTSDF) / (interpolatedTSDF - prevTSDF);
            float3 approxPos = float3(cameraMatrix[0][3], cameraMatrix[1][3], cameraMatrix[2][3]) / (roomSize * 1000.0f / voxelSize) + preciseTime * worldDir;
            //outputBuffer[int2(id.x, imageHeight - id.y - 1)] = float4(approxNorm, 1);
            float intensity = dot(approxNorm, worldDir);
            intensity = clamp(intensity, 0, 1);
            outputBuffer[int2(id.x, imageHeight - id.y - 1)] = float4(intensity, intensity, intensity, 1);
            normalMapBuffer[id.y * imageWidth + id.x] = approxNorm;
            vertexMapBuffer[id.y * imageWidth + id.x] = approxPos * roomSize * 1000.0f / voxelSize;
            //outputBuffer[int2(id.x, imageHeight - id.y - 1)] = float4(1 - i / (float) rayTraceSteps, 1 - i / (float) rayTraceSteps, 1 - i / (float) rayTraceSteps, 1);
            return;
        }
        step = max(.1, interpolatedTSDF * .75f);
        worldPos += worldDir * step;
        prevTime = time;
        prevTSDF = interpolatedTSDF;
        time += step;
    }
    outputBuffer[int2(id.x, imageHeight - id.y - 1)] = float4(0, 0, 0, 1);
}

[numthreads(8, 8, 1)]
void ICP(int3 id : SV_DispatchThreadID, int3 threadID : SV_GroupThreadID, int3 groupID : SV_GroupID)
{
    //int ICPStartIndex = (imageHeight - id.y - 1) * imageWidth + id.x;
    int ICPStartIndex = id.y * imageWidth + id.x;
    float4 currentVertex = float4(vertexBuffer[ICPStartIndex], 1);
    bool isValid = true;
    [flatten]
    if (currentVertex.z == 0)
    {
        isValid = false;
    }
    float4x4 FrameToFrameTransform = mul(invCameraMatrix, currentICPCameraMatrix);
    float4 projPoint = mul(colorIntrinsicMatrix, mul(FrameToFrameTransform, currentVertex));
    int2 newPoint = int2(round(projPoint.x / projPoint.z), round(projPoint.y / projPoint.z));
    [flatten]
    if (newPoint.x < 0 || newPoint.x >= imageWidth || newPoint.y < 0 || newPoint.y >= imageHeight)
    {
        isValid = false;
    }
    float4 prevVertex = float4(vertexMapBuffer[newPoint.y * imageWidth + newPoint.x], 1);
    //float4 prevVertex = mul(currentICPCameraMatrixInv, float4(vertexMapBuffer[newPoint.y * imageWidth + newPoint.x], 1));
    //float4 prevVertex = mul(currentICPCameraMatrix, currentVertex + float4(1, -.5, 2, 0));
    //float4 prevVertex = float4(vertexBufferPrevTest[ICPStartIndex], 1);
    //float4 prevVertex = mul(currentICPCameraMatrix, mul(float4x4(1, 0, 0, 0, 0, cos(.01), -sin(.01), 0, 0, sin(.01), cos(.01), 0, 0, 0, 0, 1), currentVertex));
    //float4 prevVertex = mul(float4x4(1, 0, 0, 0, 0, cos(.01), -sin(.01), 0, 0, sin(.01), cos(.01), 0, 0, 0, 0, 1), currentVertex);
    //float4 prevVertex = mul(cameraMatrix, currentVertex + float4(1, -.5, 2, 0));
    //float4 prevVertex = mul(cameraMatrix, float4(vertexBuffer[newPoint.y * imageWidth + newPoint.x], 1) + float4(1, -.5, 2, 0));
    //float4 prevVertex = mul(cameraMatrix, float4(vertexBuffer[newPoint.y * imageWidth + newPoint.x], 1) + float4(1, -.5, 2, 0));
    [flatten]
    if (prevVertex.z == 0)
    {
        isValid = false;
    }
    float4 estimateVertex = mul(currentICPCameraMatrix, currentVertex);
    //float4 estimateVertex = currentVertex;
    [flatten]
    if (distance(estimateVertex, prevVertex) > ICPThresholdDistance)
    {
        isValid = false;
    }
    float4 currentNormal = float4(normalBuffer[id.y * imageWidth + id.x], 0);
    float4 prevNormal = float4(normalMapBuffer[newPoint.y * imageWidth + newPoint.x], 0);
    //float4 prevNormal = float4(normalBuffer[id.y * imageWidth + id.x], 0);
    [flatten]
    if (!isfinite(currentNormal.x) || length(currentNormal) < .1 || !isfinite(prevNormal.x) || length(prevNormal) < .1)
    {
        isValid = false;
    }
    //prevNormal = mul(currentICPCameraMatrixInv, prevNormal);
    currentNormal = mul(currentICPCameraMatrix, currentNormal);
    [flatten]
    if (abs(dot(currentNormal, prevNormal)) < ICPThresholdRotation)
    {
        isValid = false;
    }
    float3 crossProd = cross(estimateVertex.xyz, prevNormal.xyz);
    float ATransposeVector[6] =
    {
        crossProd.x,
        crossProd.y,
        crossProd.z,
        prevNormal.x,
        prevNormal.y,
        prevNormal.z
    };
    float bScalar = dot(prevNormal, estimateVertex - prevVertex);
    int groupIdx = threadID.y * 8 + threadID.x;
    if (isValid)
    {
        [unroll]
        for (int i = 0; i < 6; i++)
        {
            ICPSharedData[groupIdx][21 + i] = bScalar * ATransposeVector[i];
            [unroll]
            for (int j = i; j < 6; j++)
            {
                ICPSharedData[groupIdx][i * 6 - i * (i - 1) / 2 + j - i] = ATransposeVector[i] * ATransposeVector[j];
            }
        }
    }
    else
    {
        [unroll]
        for (int i = 0; i < 27; i++)
        {
            ICPSharedData[groupIdx][i] = 0;
        }
    }
    GroupMemoryBarrierWithGroupSync();
    [unroll]
    for (int step = 64 / 2; step > 1; step >>= 1)
    {
        if (groupIdx < step)
        {
            [unroll]
            for (int i = 0; i < 27; i++)
            {
                ICPSharedData[groupIdx][i] += ICPSharedData[groupIdx + step][i];
            }
        }
        GroupMemoryBarrierWithGroupSync();
    }
    
    if (groupIdx == 0)
    {
        [unroll]
        for (int i = 0; i < 27; i++)
        {
            ICPBuffer[(groupID.y * imageWidth / 8 + groupID.x) * 27 + i] = ICPSharedData[0][i] + ICPSharedData[1][i];
        }
    }

}


[numthreads(256, 1, 1)]
void ICPReduction(int3 id : SV_DispatchThreadID, int3 threadID : SV_GroupThreadID, int3 groupID : SV_GroupID)
{
    int pos = groupID.x * 256 * 2 + threadID.x;
    [unroll]
    for (int i = 0; i < 27; i++)
    {
        ICPSharedData[threadID.x][i] = ICPBuffer[pos * 27 + i] + ICPBuffer[(pos + 256) * 27 + i];
    }
    GroupMemoryBarrierWithGroupSync();
    for (int step = 256 / 2; step > 0; step >>= 1)
    {
        if (threadID.x < step)
        {
            [unroll]
            for (int i = 0; i < 27; i++)
            {
                ICPSharedData[threadID.x][i] += ICPSharedData[threadID.x + step][i];
            }
        }
        GroupMemoryBarrierWithGroupSync();
    }
    if (threadID.x == 0)
    {
        [unroll]
        for (int i = 0; i < 27; i++)
        {
            ICPReductionBuffer[groupID.x * 27 + i] = ICPSharedData[0][i];
        }
    }
}