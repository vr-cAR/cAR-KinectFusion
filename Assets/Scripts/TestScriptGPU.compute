// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Depth
#pragma kernel DrawDepth
#pragma kernel Smooth
#pragma kernel ComputeNormals
#pragma kernel TSDFUpdate

struct TSDF
{
    float tsdfValue;
    float weight;
};

Texture2D<float4> pixelBuffer;
RWTexture2D<float4> outputBuffer;
StructuredBuffer<uint> depthBuffer;
RWStructuredBuffer<uint> leftDepthBuffer;
RWStructuredBuffer<float3> normalBuffer;
RWStructuredBuffer<float3> vertexBuffer;
RWStructuredBuffer<TSDF> TSDFBuffer;

uint imageWidth;
uint imageHeight;
float leftEyeTranslationDistance;

float spatialWeight;
float rangeWeight;
uint neighborSize;
float4x4 cameraMatrix;
float4x4 invCameraMatrix;
float truncationDist;
int voxelSize;

float getDepth(int2 pos)
{
    int depth = depthBuffer[(pos.y * imageWidth + pos.x) / 2];
    int upperHalf = depth >> 16;
    int lowerHalf = depth & (0xFFFF);
    
    if ((pos.x & 1) == 0)
    {
        depth = lowerHalf;
    }
    else
    {
        depth = upperHalf;
    }
    return depth;
}

[numthreads(8, 8, 1)]
void Depth(uint3 id : SV_DispatchThreadID)
{
    float depth = getDepth(id.xy);
    if (depth != 0)
    {
        float newPos = id.x - leftEyeTranslationDistance * imageWidth / depth;
        uint roundedNewPos = round(newPos);
        if (roundedNewPos >= 0 && roundedNewPos < imageWidth)
        {
            InterlockedMin(leftDepthBuffer[id.y * imageWidth + roundedNewPos], depth);
        }
    }
}

[numthreads(8, 8, 1)]
void DrawDepth(uint3 id : SV_DispatchThreadID)
{
    float depth = getDepth(id.xy);
    if (depth != 0)
    {
        float newPos = id.x - leftEyeTranslationDistance * imageWidth / depth;
        uint roundedNewPos = round(newPos);
        if (roundedNewPos >= 0 && roundedNewPos < imageWidth && leftDepthBuffer[id.y * imageWidth + roundedNewPos] == depth)
        {
            outputBuffer[int2(roundedNewPos, imageHeight - id.y - 1)] = pixelBuffer[int2(id.x, imageHeight - id.y - 1)];
        }
    }
    
    else
    {
        outputBuffer[int2(id.x, imageHeight - id.y - 1)] = pixelBuffer[int2(id.x, imageHeight - id.y - 1)];
    }
    
}

float bilateralFilterWeight(int2 origPos, int2 newPos)
{
    return exp(-((origPos.x - newPos.x) * (origPos.x - newPos.x) + (origPos.y - newPos.y) * (origPos.y - newPos.y)) * 1 / (spatialWeight * spatialWeight)) *
           exp(-((getDepth(origPos) - getDepth(newPos)) * (getDepth(origPos) - getDepth(newPos))) * 1 / (rangeWeight * rangeWeight));
}

[numthreads(8, 8, 1)]
void Smooth(int3 id : SV_DispatchThreadID)
{
    float normFactor = 0;
    float totWeight = 0;
    for (int a = 0; a < 2 * neighborSize; a++)
    {
        for (int b = 0; b < 2 * neighborSize; b++)
        {
            float currentWeight = bilateralFilterWeight(id.xy, int2(id.x + b - neighborSize, id.y + a - neighborSize));
            normFactor += currentWeight;
            totWeight += currentWeight * getDepth(int2(id.x + b - neighborSize, id.y + a - neighborSize));
        }
    }
    vertexBuffer[id.y * imageWidth + imageWidth - id.x - 1] = (int) ((float) totWeight / normFactor) *
                                                              mul(invCameraMatrix, float4((id.x - (int) imageWidth / 2) / (float) imageWidth, (id.y - (int) imageHeight / 2) / (float) imageHeight, 1, 1)).xyz;
}

[numthreads(8, 8, 1)]
void ComputeNormals(int3 id : SV_DispatchThreadID)
{
    float3 normVector = cross(vertexBuffer[(id.y + 1) * imageWidth + id.x] - vertexBuffer[id.y * imageWidth + id.x],
                              vertexBuffer[id.y * imageWidth + id.x + 1] - vertexBuffer[id.y * imageWidth + id.x]);
    normalBuffer[(imageHeight - id.y - 1) * imageWidth + (imageWidth - id.x - 1)] = normalize(normVector);
}

[numthreads(8, 8, 8)]
void TSDFUpdate(int3 id : SV_DispatchThreadID)
{
    float3 globalPos = asfloat(id);
    float3 newPos = mul(invCameraMatrix, float4(globalPos, 1)).xyz;
    //not sure if this works the way I think it does
    int2 projPoint = round(float2(newPos.x / newPos.z, newPos.y / newPos.z));
    if (projPoint.x >= 0 && projPoint.x < imageWidth && projPoint.y >= 0 && projPoint.y < imageHeight)
    {
        float weight = distance(float3(cameraMatrix[0][3], cameraMatrix[1][3], cameraMatrix[2][3]), globalPos) / length(float3(projPoint, 1)) - vertexBuffer[projPoint.y * imageWidth + projPoint.x];
        if (weight >= -truncationDist)
        {
            float sdf = min(1, weight / truncationDist) * sign(weight);
            TSDFBuffer[id.z * voxelSize * voxelSize + id.y * voxelSize + id.x].tsdfValue = sdf;
        }
    }
}